package glemon

import "fmt"

/*
** Routines to construction the finite state machine for the LEMON
** parser generator.
*/

/* Find a precedence symbol of every rule in the grammar.
**
** Those rules which have a precedence symbol coded in the input
** grammar using the "[symbol]" construct will already have the
** rp->precsym field filled.  Other rules take as their precedence
** symbol the first RHS symbol with a defined precedence.  If there
** are not RHS symbols with a defined precedence, the precedence
** symbol field is left blank.
** 设置产生式可能的优先级，如果产生式后面已经有了代表优先级的“伪”终结符[XXX]，那么
** 在Parse()函数中，会被设置到precsym属性中。否则的话以产生式右边第一个具有优先级的
** 符号来作为该产生式的优先级
*/

func FindRulePrecedences(xp *lemon) {
	var rp *rule
	for rp = xp.rule; rp != nil; rp = rp.next {
		if rp.precsym == nil {
			for i := 0; i < rp.nrhs; i++ {
				if rp.rhs[i].prec >= 0 {
					rp.precsym = rp.rhs[i]
					break
				}

			}
		}
	}
}

/* Find all nonterminals which will generate the empty string.
** Then go back and compute the first sets of every nonterminal.
** The first set is the set of all terminal symbols which can begin
** a string generated by that nonterminal.
*/
func  FindFirstSets(lemp *lemon) {

	for _, symbol := range lemp.symbols {
		symbol.lambda = false
	}

	// 以为symol已经排过序
	for i := lemp.nterminal; i < lemp.nsymbol; i++ {
		lemp.symbols[i].firstset = SetNew()
	}

	var i int
	// First compute all lambdas
	// 判断一个文法符号是否可以为空串，在语法书中一般用ε(epsion)表示，此处用lambda
	for {
		progress := false

		for rp := lemp.rule; rp != nil; rp = rp.next {
			if rp.lhs.lambda {
				continue
			}

			for i = 0; i < rp.nrhs; i++ {
				if !rp.rhs[i].lambda { // 如果产生式右边有个文法符号不可能是空串，那么产生式左边也不可能是空串
					break
				}
			}

			if i == rp.nrhs { // 到达产生式末尾
				rp.lhs.lambda = true
				progress = true
			}
		}

		if !progress {
			break
		}
	}

	/*fmt.Printf("symbol lambda \n")
	for  i := 0; i < lemp.nsymbol; i++  {
		fmt.Printf("symbol %s : %v \n", lemp.symbols[i].name, lemp.symbols[i].lambda)
	}
	fmt.Printf("symbol lambda end----- \n")*/

	fmt.Printf("Now compute all first sets \n ")
	// Now compute all first sets
	for {
		var s1, s2 *symbol
		progress := 0
		for rp:=lemp.rule; rp!= nil; rp = rp.next {
			s1 = rp.lhs
			for i:=0; i<rp.nrhs; i++ {
				s2 = rp.rhs[i]
				if s2.typ == TERMINAL {
					progress += SetAdd(s1.firstset, s2.index)
					break
				} else if s1 == s2 {
					if !s1.lambda {
						break
					}
				} else {
					progress += SetUnion(s1.firstset, s2.firstset)
					if !s2.lambda {
						break
					}
				}
			}

		}

		if progress == 0 {
			break
		}
	}

}
