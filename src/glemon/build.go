package glemon

import "fmt"

/*
** Routines to construction the finite state machine for the LEMON
** parser generator.
*/

/* Find a precedence symbol of every rule in the grammar.
**
** Those rules which have a precedence symbol coded in the input
** grammar using the "[symbol]" construct will already have the
** rp->precsym field filled.  Other rules take as their precedence
** symbol the first RHS symbol with a defined precedence.  If there
** are not RHS symbols with a defined precedence, the precedence
** symbol field is left blank.
** 设置产生式可能的优先级，如果产生式后面已经有了代表优先级的“伪”终结符[XXX]，那么
** 在Parse()函数中，会被设置到precsym属性中。否则的话以产生式右边第一个具有优先级的
** 符号来作为该产生式的优先级
*/

func FindRulePrecedences(xp *lemon) {
	var rp *rule
	for rp = xp.rule; rp != nil; rp = rp.next {
		if rp.precsym == nil {
			for i := 0; i < rp.nrhs; i++ {
				if rp.rhs[i].prec >= 0 {
					rp.precsym = rp.rhs[i]
					break
				}

			}
		}
	}
}

/* Find all nonterminals which will generate the empty string.
** Then go back and compute the first sets of every nonterminal.
** The first set is the set of all terminal symbols which can begin
** a string generated by that nonterminal.
*/
func FindFirstSets(lemp *lemon) {

	for _, symbol := range lemp.symbols {
		symbol.lambda = false
	}

	// 以为symol已经排过序
	for i := lemp.nterminal; i < lemp.nsymbol; i++ {
		lemp.symbols[i].firstset = SetNew()
	}

	var i int
	// First compute all lambdas
	// 判断一个文法符号是否可以为空串，在语法书中一般用ε(epsion)表示，此处用lambda
	for {
		progress := false

		for rp := lemp.rule; rp != nil; rp = rp.next {
			if rp.lhs.lambda {
				continue
			}

			for i = 0; i < rp.nrhs; i++ {
				if !rp.rhs[i].lambda { // 如果产生式右边有个文法符号不可能是空串，那么产生式左边也不可能是空串
					break
				}
			}

			if i == rp.nrhs { // 到达产生式末尾
				rp.lhs.lambda = true
				progress = true
			}
		}

		if !progress {
			break
		}
	}

	/*fmt.Printf("symbol lambda \n")
	for  i := 0; i < lemp.nsymbol; i++  {
		fmt.Printf("symbol %s : %v \n", lemp.symbols[i].name, lemp.symbols[i].lambda)
	}
	fmt.Printf("symbol lambda end----- \n")*/

	fmt.Printf("Now compute all first sets \n ")
	// Now compute all first sets
	for {
		var s1, s2 *symbol
		progress := 0
		for rp := lemp.rule; rp != nil; rp = rp.next {
			s1 = rp.lhs
			for i := 0; i < rp.nrhs; i++ {
				s2 = rp.rhs[i]
				if s2.typ == TERMINAL {
					progress += SetAdd(s1.firstset, s2.index)
					break
				} else if s1 == s2 {
					if !s1.lambda {
						break
					}
				} else {
					progress += SetUnion(s1.firstset, s2.firstset)
					if !s2.lambda {
						break
					}
				}
			}

		}

		if progress == 0 {
			break
		}
	}

}

func FindStates(lemp *lemon) {
	var sp *symbol
	var rp *rule

	Configlist_init()

	// 如果指定了某个非终结符为开始符号则使用该符号，否则使用第一个产生式的非终结符作为开始符号
	if len(lemp.start) > 0 {
		sp = Symbol_find(lemp.start)
		if sp == nil {
			ErrorMsg(lemp.filename, 0,
				fmt.Sprintf("The specified start symbol \"%s\" is not in a nonterminal "+
					"of the grammar.  \"%s\" will be used as the start symbol instead.",
					lemp.start, lemp.rule.lhs.name))
			lemp.errorcnt++
			sp = lemp.rule.lhs
		}
	} else {
		sp = lemp.rule.lhs
	}

	// Make sure the start symbol doesn't occur on the right-hand side of
	// any rule.  Report an error if it does.  (YACC would generate a new
	// start symbol in this case.)

	for rp := lemp.rule; rp != nil; rp = rp.next {
		for i := 0; i < rp.nrhs; i++ {
			if rp.rhs[i] == sp {
				ErrorMsg(lemp.filename, 0,
					fmt.Sprintf("The start symbol \"%s\" occurs on the right-hand side "+
						"of a rule. This will result in a parser which does not work properly.", sp.name))
				lemp.errorcnt++
			}
		}
	}

	// The basis configuration set for the first state is all rules
	// which have the start symbol as their left-hand side
	for rp = sp.rule; rp != nil; rp = rp.nextlhs {
		newcfp := Configlist_addbasis(rp, 0)
		// 把index为0的symbol(即$)加到follow set
		// LR(0)分析器的第一个状态的基本项目集，就是做不含有开始符号的所有产生式，
		// 通常还有第一条产生式左边有开始符号，但是也允许开始符号出现在多条产生式的左边
		SetAdd(newcfp.fws, 0)
	}
	// 基本项目集已经计算好

	// Compute the first state.  All other states will be
	// computed automatically during the computation of the first one.
	// The returned pointer to the first state is not used.
	getstate(lemp)
}

// Return a pointer to a state which is described by the configuration
// list which has been built from calls to Configlist_add.
func getstate(lemp *lemon) *state {
	var cfp *config
	var bp *config
	var stp *state

	// Extract the sorted basis of the new state.  The basis was constructed
	// by prior calls to "Configlist_addbasis()".
	Configlist_sortbasis()
	bp = Configlist_basis()

	// Get a state with the same basis
	stp = State_find(bp)
	if stp != nil {
		//A state with the same basis already exists!  Copy all the follow-set
		// propagation links from the state under construction into the
		// preexisting state, then return a pointer to the preexisting state
		x := bp
		y := stp.bp
		for ; x != nil && y != nil; {
			Plink_copy(&y.bplp, x.bplp)
			Plink_delete(x.fplp)
			x.fplp = nil
			x.bplp = nil

			x = x.bp
			y = y.bp
		}

		cfp = Configlist_return()
		Configlist_eat(cfp)
	} else {
		// This really is a new state.  Construct all the details
		Configlist_closure(lemp);  // Compute the configuration closure
		Configlist_sort();         // Sort the configuration closure
		cfp = Configlist_return(); // Get a pointer to the config list
		stp = State_new();         // A new state structure
		stp.bp = bp                // Remember the configuration basis
		stp.cfp = cfp              // Remember the configuration closure
		stp.index = lemp.nstate    // Every state gets a sequence number
		lemp.nstate ++
		stp.ap = nil              // No actions, yet.
		State_insert(stp, stp.bp) //Add to the state table
		buildshifts(lemp, stp)    // Recursively compute successor states
	}

	return nil
}

func buildshifts(lemp *lemon, stp *state) {
	var cfp *config   //  For looping through the config closure of "stp"
	var bcfp *config  // For the inner loop on config closure of "stp"
	var new *config   //
	var sp *symbol    // Symbol following the dot in configuration "cfp"
	var bsp *symbol   // Symbol following the dot in configuration "bcfp"
	var newstp *state // A pointer to a successor state */

	// Each configuration becomes complete after it contibutes to a successor
	// state. Initially, all configurations are incomplete
	for cfp = stp.cfp; cfp != nil; cfp = cfp.next {
		cfp.status = INCOMPLETE
	}

	for cfp = stp.cfp; cfp != nil; cfp = cfp.next {
		if cfp.status == COMPLETE { // Already used by inner loop
			continue
		}
		if cfp.dot == cfp.rp.nrhs { // Can't shift this config
			continue
		}
		Configlist_reset()
		sp = cfp.rp.rhs[cfp.dot] // Symbol after the dot

		// For every configuration in the state "stp" which has the symbol "sp"
		// following its dot, add the same configuration to the basis set under
		// construction but with the dot shifted one symbol to the right.
		for bcfp = cfp; bcfp != nil; bcfp = bcfp.next {
			if bcfp.status == COMPLETE {
				continue
			}
			if bcfp.dot == bcfp.rp.nrhs { // Can't shift this config
				continue
			}
			bsp = bcfp.rp.rhs[bcfp.dot]
			if bsp != sp {  // Must be same as for "cfp"
				continue
			}
			bcfp.status = COMPLETE
			new = Configlist_addbasis(bcfp.rp, bcfp.dot +1)
			Plink_add(&new.bplp, bcfp)
		}

		// Get a pointer to the state described by the basis configuration set
		// constructed in the preceding loop
		newstp = getstate(lemp)

		//The state "newstp" is reached from the state "stp" by a shift action
		// on the symbol "sp
		// Action_add(&stp->ap,SHIFT,sp,(char *)newstp) //TODO
	}
}
