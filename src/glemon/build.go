package glemon

import (
	"fmt"
	"unsafe"
)

/*
** Routines to construction the finite state machine for the LEMON
** parser generator.
*/

/* Find a precedence symbol of every rule in the grammar.
**
** Those rules which have a precedence symbol coded in the input
** grammar using the "[symbol]" construct will already have the
** rp->precsym field filled.  Other rules take as their precedence
** symbol the first RHS symbol with a defined precedence.  If there
** are not RHS symbols with a defined precedence, the precedence
** symbol field is left blank.
** 设置产生式可能的优先级，如果产生式后面已经有了代表优先级的“伪”终结符[XXX]，那么
** 在Parse()函数中，会被设置到precsym属性中。否则的话以产生式右边第一个具有优先级的
** 符号来作为该产生式的优先级
*/

func FindRulePrecedences(xp *lemon) {
	var rp *rule
	for rp = xp.rule; rp != nil; rp = rp.next {
		if rp.precsym == nil {
			for i := 0; i < rp.nrhs; i++ {
				if rp.rhs[i].prec >= 0 {
					rp.precsym = rp.rhs[i]
					break
				}

			}
		}
	}
}

/* Find all nonterminals which will generate the empty string.
** Then go back and compute the first sets of every nonterminal.
** The first set is the set of all terminal symbols which can begin
** a string generated by that nonterminal.
*/
func FindFirstSets(lemp *lemon) {

	for _, symbol := range lemp.symbols {
		symbol.lambda = false
	}

	// 以为symol已经排过序
	for i := lemp.nterminal; i < lemp.nsymbol; i++ {
		lemp.symbols[i].firstset = SetNew()
	}

	var i int
	// First compute all lambdas
	// 判断一个文法符号是否可以为空串，在语法书中一般用ε(epsion)表示，此处用lambda
	for {
		progress := false

		for rp := lemp.rule; rp != nil; rp = rp.next {
			if rp.lhs.lambda {
				continue
			}

			for i = 0; i < rp.nrhs; i++ {
				if !rp.rhs[i].lambda { // 如果产生式右边有个文法符号不可能是空串，那么产生式左边也不可能是空串
					break
				}
			}

			if i == rp.nrhs { // 到达产生式末尾
				rp.lhs.lambda = true
				progress = true
			}
		}

		if !progress {
			break
		}
	}

	/*fmt.Printf("symbol lambda \n")
	for  i := 0; i < lemp.nsymbol; i++  {
		fmt.Printf("symbol %s : %v \n", lemp.symbols[i].name, lemp.symbols[i].lambda)
	}
	fmt.Printf("symbol lambda end----- \n")*/

	fmt.Printf("Now compute all first sets \n ")
	// Now compute all first sets
	for {
		var s1, s2 *symbol
		progress := 0
		for rp := lemp.rule; rp != nil; rp = rp.next {
			s1 = rp.lhs
			for i := 0; i < rp.nrhs; i++ {
				s2 = rp.rhs[i]
				if s2.typ == TERMINAL {
					progress += SetAdd(s1.firstset, s2.index)
					break
				} else if s1 == s2 {
					if !s1.lambda {
						break
					}
				} else {
					progress += SetUnion(s1.firstset, s2.firstset)
					if !s2.lambda {
						break
					}
				}
			}

		}

		if progress == 0 {
			break
		}
	}

}

func FindStates(lemp *lemon) {
	var sp *symbol
	var rp *rule

	Configlist_init()

	// 如果指定了某个非终结符为开始符号则使用该符号，否则使用第一个产生式的非终结符作为开始符号
	if len(lemp.start) > 0 {
		sp = Symbol_find(lemp.start)
		if sp == nil {
			ErrorMsg(lemp.filename, 0,
				fmt.Sprintf("The specified start symbol \"%s\" is not in a nonterminal "+
					"of the grammar.  \"%s\" will be used as the start symbol instead.",
					lemp.start, lemp.rule.lhs.name))
			lemp.errorcnt++
			sp = lemp.rule.lhs
		}
	} else {
		sp = lemp.rule.lhs
	}

	// Make sure the start symbol doesn't occur on the right-hand side of
	// any rule.  Report an error if it does.  (YACC would generate a new
	// start symbol in this case.)

	for rp := lemp.rule; rp != nil; rp = rp.next {
		for i := 0; i < rp.nrhs; i++ {
			if rp.rhs[i] == sp {
				ErrorMsg(lemp.filename, 0,
					fmt.Sprintf("The start symbol \"%s\" occurs on the right-hand side "+
						"of a rule. This will result in a parser which does not work properly.", sp.name))
				lemp.errorcnt++
			}
		}
	}

	// The basis configuration set for the first state is all rules
	// which have the start symbol as their left-hand side
	for rp = sp.rule; rp != nil; rp = rp.nextlhs {
		newcfp := Configlist_addbasis(rp, 0)
		// 把index为0的symbol(即$)加到follow set， 即计算产生式的第一条规则
		// LR(0)分析器的第一个状态的基本项目集，就是做不含有开始符号的所有产生式，
		// 通常还有第一条产生式左边有开始符号，但是也允许开始符号出现在多条产生式的左边
		SetAdd(newcfp.fws, 0)
	}
	// 基本项目集已经计算好

	// Compute the first state.  All other states will be
	// computed automatically during the computation of the first one.
	// The returned pointer to the first state is not used.
	getstate(lemp)
}

// Return a pointer to a state which is described by the configuration
// list which has been built from calls to Configlist_add.
func getstate(lemp *lemon) *state {
	var cfp *config
	var bp *config
	var stp *state

	// Extract the sorted basis of the new state.  The basis was constructed
	// by prior calls to "Configlist_addbasis()".
	Configlist_sortbasis()
	bp = Configlist_basis()

	// Get a state with the same basis
	stp = State_find(bp)
	if stp != nil {
		// A state with the same basis already exists!  Copy all the follow-set
		// propagation links from the state under construction into the
		// preexisting state, then return a pointer to the preexisting state
		// x,y两个作为表头的两个链表的基本项目是一样的，那么它们闭包运算的所得的项目集也是一样的。
		x := bp
		y := stp.bp
		for ; x != nil && y != nil; {
			Plink_copy(&y.bplp, x.bplp)
			Plink_delete(x.fplp)
			x.fplp = nil
			x.bplp = nil

			x = x.bp
			y = y.bp
		}

		cfp = Configlist_return()
		Configlist_eat(cfp)
	} else {
		// This really is a new state.  Construct all the details
		Configlist_closure(lemp);  // Compute the configuration closure
		Configlist_sort();         // Sort the configuration closure
		cfp = Configlist_return(); // Get a pointer to the config list 此时已经有一个新的状态了
		stp = State_new();         // A new state structure
		stp.bp = bp                // Remember the configuration basis
		stp.cfp = cfp              // Remember the configuration closure
		stp.index = lemp.nstate    // Every state gets a sequence number
		lemp.nstate ++             //
		stp.ap = nil               // No actions, yet.
		State_insert(stp, stp.bp)  // Add to the state table
		buildshifts(lemp, stp)     // Recursively compute successor states
	}

	return stp
}

func buildshifts(lemp *lemon, stp *state) {
	var cfp *config   //  For looping through the config closure of "stp"
	var bcfp *config  // For the inner loop on config closure of "stp"
	var new *config   //
	var sp *symbol    // Symbol following the dot in configuration "cfp"
	var bsp *symbol   // Symbol following the dot in configuration "bcfp"
	var newstp *state // A pointer to a successor state */

	// Each configuration becomes complete after it contibutes to a successor
	// state. Initially, all configurations are incomplete
	for cfp = stp.cfp; cfp != nil; cfp = cfp.next {
		cfp.status = INCOMPLETE
	}

	for cfp = stp.cfp; cfp != nil; cfp = cfp.next {
		if cfp.status == COMPLETE { // Already used by inner loop
			continue
		}
		if cfp.dot == cfp.rp.nrhs { // Can't shift this config
			continue
		}
		Configlist_reset()
		sp = cfp.rp.rhs[cfp.dot] // Symbol after the dot 分割点之后的符号，即要进行移进（shift）的符号

		// For every configuration in the state "stp" which has the symbol "sp"
		// following its dot, add the same configuration to the basis set under
		// construction but with the dot shifted one symbol to the right.
		for bcfp = cfp; bcfp != nil; bcfp = bcfp.next {
			if bcfp.status == COMPLETE {
				continue
			}
			if bcfp.dot == bcfp.rp.nrhs { // Can't shift this config
				continue
			}
			bsp = bcfp.rp.rhs[bcfp.dot]
			if bsp != sp { // Must be same as for "cfp"
				continue
			}
			bcfp.status = COMPLETE
			new = Configlist_addbasis(bcfp.rp, bcfp.dot+1) // 移进之后就有了一个新的基本项目，加入到基本项目集合中
			Plink_add(&new.bplp, bcfp)                     // new是bcfp经过shift符号bsp得来的，用bcfp构建新的Plink挂载到new的bplp列表上
			// 把new称为“后继”项目，bcfp称为“前承”项目
		}

		// Get a pointer to the state described by the basis configuration set
		// constructed in the preceding loop
		newstp = getstate(lemp) // 对新的基本项目集调用getstate

		// The state "newstp" is reached from the state "stp" by a shift action
		// on the symbol "sp 记录shift动作
		Action_add(&stp.ap, SHIFT, sp, unsafe.Pointer(newstp)) // TODO
	}
}

// Construct the propagation links
func FindLinks(lemp *lemon) {
	var i int
	var cfp, other *config
	var stp *state
	var plp *plink

	// Housekeeping detail:
	// Add to every propagate link a pointer back to the state to
	// which the link is attached.
	for i = 0; i < lemp.nstate; i++ {
		stp = lemp.sorted[i];
		for cfp = stp.cfp; cfp != nil; cfp = cfp.next {
			cfp.stp = stp // 把项目和状态进行绑定
		}
	}

	// Convert all backlinks into forward links.  Only the forward
	// links are used in the follow-set computation.
	for i = 0; i < lemp.nstate; i++ {
		stp = lemp.sorted[i];
		for cfp = stp.cfp; cfp != nil; cfp = cfp.next {
			for plp = cfp.bplp; plp != nil; plp = plp.next {
				other = plp.cfp
				Plink_add(&other.fplp, cfp) //TODO ??? 在Configlist_closure方法中也会把一个cfp加到另一个cfp的fplp中，会不会和这里重复
			}
		}
	}
}

// Compute all followsets.
// A followset is the set of all symbols which can come immediately
// after a configuration.

func FindFollowSets(lemp *lemon) {
	var cfp *config
	var plp *plink
	var change int

	for i := 0; i < lemp.nstate; i++ {
		for cfp = lemp.sorted[i].cfp; cfp != nil; cfp = cfp.next {
			cfp.status = INCOMPLETE
		}
	}

	for {
		progress := false
		for i := 0; i < lemp.nstate; i++ {
			for cfp = lemp.sorted[i].cfp; cfp != nil; cfp = cfp.next {
				if cfp.status == COMPLETE {
					continue
				}

				for plp = cfp.fplp; plp != nil; plp = plp.next {
					change = SetUnion(plp.cfp.fws, cfp.fws)
					if change > 0 {
						plp.cfp.status = INCOMPLETE
						progress = true
					}
				}
				// cfp的所有后继项目的fws都合并了cfp.fws，那么cfp就完成使命了
				cfp.status = COMPLETE
			}
		}

		if !progress {
			break
		}
	}
}

// Compute the reduce actions, and resolve conflicts.
func FindActions(lemp *lemon) {

	var cfp *config
	var stp *state
	var sp *symbol
	var rp *rule

	// Add all of the reduce actions
	// A reduce action is added for each element of the followset of
	// a configuration which has its dot at the extreme right.
	for i := 0; i < lemp.nstate; i++ {
		stp = lemp.sorted[i]
		for cfp = stp.cfp; cfp != nil; cfp = cfp.next {
			if cfp.rp.nrhs == cfp.dot {
				for j := 0; j < lemp.nterminal; j++ {
					if cfp.fws[j] > 0 {
						Action_add(&stp.ap, REDUCE, lemp.symbols[j], unsafe.Pointer(cfp.rp))
					}
				}
			}
		}
	}

	// Add the accepting token
	if len(lemp.start) > 0 {
		sp = Symbol_find(lemp.start)
		if sp == nil {
			sp = lemp.rule.lhs
		}
	} else {
		sp = lemp.rule.lhs
	}

	// Add to the first state (which is always the starting state of the finite state
	// machine) an action to ACCEPT if the lookahead is the start nonterminal.
	Action_add(&lemp.sorted[0].ap, ACCEPT, sp, nil)

	// Resolve conflicts
	for i := 0; i < lemp.nstate; i++ {
		stp := lemp.sorted[i]
		// assert(stp.ap  != nil)
		stp.ap = Action_sort(stp.ap)
		for ap := stp.ap; ap != nil && ap.next != nil; ap = ap.next {
			// 同一个lookahead token可以触发两个动作，那么就会有冲突
			for nap := ap.next; nap != nil && nap.sp == ap.sp; nap = nap.next {
				// The two actions "ap" and "nap" have the same lookahead.
				// Figure out which one should be used
				lemp.nconflict += resolve_conflict(ap, nap, lemp.errsym)
			}
		}
	}

	// Report an error for each rule that can never be reduced.
	for rp = lemp.rule; rp != nil; rp = rp.next {
		rp.canReduce = false
	}
	for i := 0; i < lemp.nstate; i++ {
		for ap := lemp.sorted[i].ap; ap != nil && ap.next != nil; ap = ap.next {
			if ap.typ == REDUCE {
				ap.rp.canReduce = true
			}
		}
	}
	// 对无法规约的产生式报告错误信息
	for rp = lemp.rule; rp != nil; rp = rp.next {
		if rp.canReduce {
			continue
		}
		ErrorMsg(lemp.filename, rp.ruleline, "This rule can not be reduced.\n")
		lemp.errorcnt ++
	}

}

/* Resolve a conflict between the two given actions.  If the
** conflict can't be resolve, return non-zero.
**
** NO LONGER TRUE:
**   To resolve a conflict, first look to see if either action
**   is on an error rule.  In that case, take the action which
**   is not associated with the error rule.  If neither or both
**   actions are associated with an error rule, then try to
**   use precedence to resolve the conflict.
**
** If either action is a SHIFT, then it must be apx.  This
** function won't work if apx->type==REDUCE and apy->type==SHIFT.
** 不可能出现具有相同lookahead token的两个移进操作。因为在一个状态中，对于一个入栈
** 符号，只有一个移进动作。
** 不可能出现先归约后移进的两个动作，这是由于移进为工作链表ap进行排序了，SHIFT在ACCEPT
** 之前，ACCEPT在REDUCE之前。因为apx和apy，要么前者是移进、后者为归约，或者都为归约。
**
** 总之，当移进和归约之间无法确定时，默认采用移进策略；当归约与归约之间无法确定时，采用居前的
** 产生式进行归约。这种代码中可以看出来，当无法解决冲突时，排在后面的apy的标志改为conflict。
** 这么做与动作链表的排序有关，排序时
*/
func resolve_conflict(apx *action, apy *action, errsym *symbol) int {
	var spx, spy *symbol
	var errcnt = 0
	//assert apx.sp==apy.sp  // Otherwise there would be no conflict
	if apx.typ == SHIFT && apy.typ == REDUCE { // 需要使用符号的优先级来解决冲突
		spx = apx.sp
		spy = apy.rp.precsym
		if spy == nil || spx.prec < 0 || spy.prec < 0 {
			// Not enough precedence information. 没有优先级信息
			apy.typ = CONFLICT
			errcnt ++
		} else if spx.prec > spy.prec { // Lower precedence wins
			apy.typ = RD_RESOLVED // 优先级小的赢(TODO ???)，因此修改apy的动作标志，表示归约被解除
		} else if spx.prec < spy.prec {
			apx.typ = SH_RESOLVED
		} else if spx.prec == spy.prec && spx.assoc == RIGHT { // 优先级相同，使用结合性
			apy.typ = RD_RESOLVED
		} else if spx.prec == spy.prec && spx.assoc == LEFT {
			apx.typ = SH_RESOLVED
		} else {
			// assert spx.prec == spy.prec && spx.assoc == NONE
			apy.typ = CONFLICT
			errcnt ++
		}
	} else if apx.typ == REDUCE && apy.typ == REDUCE {
		spx = apx.rp.precsym
		spy = apy.rp.precsym
		if spx == nil || spy == nil || spx.prec < 0 || spy.prec < 0 || spx.prec == spy.prec {
			apy.typ = CONFLICT
			errcnt++
		} else if spx.prec > spy.prec {
			apy.typ = RD_RESOLVED
		} else if spx.prec < spy.prec {
			apx.typ = RD_RESOLVED
		}
	} else {
		/*assert(
			apx.typ == SH_RESOLVED ||
			apx.typ == RD_RESOLVED ||
			apx.typ == CONFLICT ||
			apy.typ == SH_RESOLVED ||
			apy.typ == RD_RESOLVED ||
			apy.typ == CONFLICT
		)*/

		// The REDUCE/SHIFT case cannot happen because SHIFTs come before
		// REDUCEs on the list.  If we reach this point it must be because
		// the parser conflict had already been resolved.
	}
	return errcnt
}
