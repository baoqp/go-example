package glemon

import "fmt"

/*
** Routines to construction the finite state machine for the LEMON
** parser generator.
*/

/* Find a precedence symbol of every rule in the grammar.
**
** Those rules which have a precedence symbol coded in the input
** grammar using the "[symbol]" construct will already have the
** rp->precsym field filled.  Other rules take as their precedence
** symbol the first RHS symbol with a defined precedence.  If there
** are not RHS symbols with a defined precedence, the precedence
** symbol field is left blank.
** 设置产生式可能的优先级，如果产生式后面已经有了代表优先级的“伪”终结符[XXX]，那么
** 在Parse()函数中，会被设置到precsym属性中。否则的话以产生式右边第一个具有优先级的
** 符号来作为该产生式的优先级
*/

func FindRulePrecedences(xp *lemon) {
	var rp *rule
	for rp = xp.rule; rp != nil; rp = rp.next {
		if rp.precsym == nil {
			for i := 0; i < rp.nrhs; i++ {
				if rp.rhs[i].prec >= 0 {
					rp.precsym = rp.rhs[i]
					break
				}

			}
		}
	}
}

/* Find all nonterminals which will generate the empty string.
** Then go back and compute the first sets of every nonterminal.
** The first set is the set of all terminal symbols which can begin
** a string generated by that nonterminal.
*/
func  FindFirstSets(lemp *lemon) {

	for _, symbol := range lemp.symbols {
		symbol.lambda = false
	}

	// 以为symol已经排过序
	for i := lemp.nterminal; i < lemp.nsymbol; i++ {
		lemp.symbols[i].firstset = SetNew()
	}

	var i int
	// First compute all lambdas
	// 判断一个文法符号是否可以为空串，在语法书中一般用ε(epsion)表示，此处用lambda
	for {
		progress := false

		for rp := lemp.rule; rp != nil; rp = rp.next {
			if rp.lhs.lambda {
				continue
			}

			for i = 0; i < rp.nrhs; i++ {
				if !rp.rhs[i].lambda { // 如果产生式右边有个文法符号不可能是空串，那么产生式左边也不可能是空串
					break
				}
			}

			if i == rp.nrhs { // 到达产生式末尾
				rp.lhs.lambda = true
				progress = true
			}
		}

		if !progress {
			break
		}
	}

	/*fmt.Printf("symbol lambda \n")
	for  i := 0; i < lemp.nsymbol; i++  {
		fmt.Printf("symbol %s : %v \n", lemp.symbols[i].name, lemp.symbols[i].lambda)
	}
	fmt.Printf("symbol lambda end----- \n")*/

	fmt.Printf("Now compute all first sets \n ")
	// Now compute all first sets
	for {
		var s1, s2 *symbol
		progress := 0
		for rp:=lemp.rule; rp!= nil; rp = rp.next {
			s1 = rp.lhs
			for i:=0; i<rp.nrhs; i++ {
				s2 = rp.rhs[i]
				if s2.typ == TERMINAL {
					progress += SetAdd(s1.firstset, s2.index)
					break
				} else if s1 == s2 {
					if !s1.lambda {
						break
					}
				} else {
					progress += SetUnion(s1.firstset, s2.firstset)
					if !s2.lambda {
						break
					}
				}
			}

		}

		if progress == 0 {
			break
		}
	}

}


func FindStates(lemp *lemon) {
	var sp *symbol
	var rp *rule

	Configlist_init()

	// 如果指定了某个非终结符为开始符号则使用该符号，否则使用第一个产生式的非终结符作为开始符号
	if len(lemp.start) > 0 {
		sp = Symbol_find(lemp.start)
		if sp == nil {
			ErrorMsg(lemp.filename, 0,
				fmt.Sprintf("The specified start symbol \"%s\" is not in a nonterminal of the grammar. " +
					" \"%s\" will be used as the start symbol instead.", lemp.start, lemp.rule.lhs.name))
			lemp.errorcnt++
			sp = lemp.rule.lhs
		}
	} else {
		sp = lemp.rule.lhs
	}

	// Make sure the start symbol doesn't occur on the right-hand side of
    // any rule.  Report an error if it does.  (YACC would generate a new
    // start symbol in this case.)

	for rp := lemp.rule; rp != nil; rp = rp.next {
		for i:=0; i<rp.nrhs; i++ {
			if rp.rhs[i] == sp {
				ErrorMsg(lemp.filename, 0,
					fmt.Sprintf("The start symbol \"%s\" occurs on the right-hand side of a rule. " +
						"This will result in a parser which does not work properly.", sp.name))
				lemp.errorcnt++
			}
		}
	}

	// The basis configuration set for the first state is all rules
	// which have the start symbol as their left-hand side
	for rp=sp.rule; rp!=nil; rp=rp.nextlhs {
		newcfp := Configlist_addbasis(rp, 0)
		SetAdd(newcfp.fws,0) // TODO ???
	}

	// Compute the first state.  All other states will be
	// computed automatically during the computation of the first one.
	// The returned pointer to the first state is not used.
	getstate(lemp)
}

// Return a pointer to a state which is described by the configuration
// list which has been built from calls to Configlist_add.
func getstate(lemp *lemon) *state {
	//var cfp *config
	//var bp *config

	// Extract the sorted basis of the new state.  The basis was constructed
	// by prior calls to "Configlist_addbasis()".



	return nil
}