

	var ARG_SDECL = ""
	var ARG_PDECL = ""
	var ARG_FETCH = ""
	var ARG_STORE = ""
	if len(lemp.arg) > 0 { // TODO ???
		i := len(lemp.arg)
		for i >= 1 && util.IsSpace(lemp.arg[i-1]) {
			i --
		}

		for i >= 1 && (util.IsAlumn(lemp.arg[i-1]) || lemp.arg[i-1] == '_') {
			i --
		}
		ARG_SDECL = lemp.arg
		ARG_PDECL = lemp.arg
		ARG_FETCH = fmt.Sprintf("%s = yypParser.%s", lemp.arg, lemp.arg[i:])     // TODO ???
		ARG_STORE = fmt.Sprintf("yypParser.%s = %s", lemp.arg[i:], lemp.arg[i:]) // TODO ???
	}

	fmt.Fprintf(out, "const YYNSTATE = %d\n", lemp.nstate)
	lineno++
	fmt.Fprintf(out, "const YYNRULE = %d\n", lemp.nrule)
	lineno++;
	fmt.Fprintf(out, "const YYERRORSYMBOL = %d\n", lemp.errsym.index)
	lineno++
	fmt.Fprintf(out, "const YYERRSYMDT = yy%d\n", lemp.errsym.dtnum)
	lineno++

	if lemp.has_fallback {
		fmt.Fprintf(out, "const YYFALLBACK = 1\n")
		lineno ++
	}

	tplt_xfer(lemp.name, in, out, &lineno)

	// Generate the action table and its associates:
	//
	//  yy_action[]        A single table containing all actions.
	//  yy_lookahead[]     A table containing the lookahead for each entry in
	//                     yy_action.  Used to detect hash collisions.
	//  yy_shift_ofst[]    For each state, the offset into yy_action for
	//                     shifting terminals.
	//  yy_reduce_ofst[]   For each state, the offset into yy_action for
	//                     shifting non-terminals after a reduce.
	//  yy_default[]       Default action for each state.
	//

	// Compute the actions on all states and count them up
	ax := make([]*axset, 2*lemp.nstate, 2*lemp.nstate)

	for i := 0; i < lemp.nstate; i++ {
		stp := lemp.sorted[i]
		stp.nTknAct = 0
		stp.nNtAct = 0
		stp.iDflt = lemp.nstate + lemp.nrule
		stp.iTknOfst = NO_OFFSET
		stp.iNtOfst = NO_OFFSET
		for ap := stp.ap; ap != nil; ap = ap.next {
			if compute_action(lemp, ap) >= 0 {
				if ap.sp.index < lemp.nterminal {
					stp.nTknAct ++
				} else if ap.sp.index < lemp.nsymbol {
					stp.nNtAct ++
				} else {
					stp.iDflt = compute_action(lemp, ap)
				}
			}
		}
		ax[i*2] = &axset{}
		ax[i*2].stp = stp
		ax[i*2].isTkn = true
		ax[i*2].nAction = stp.nTknAct
		ax[i*2+1] = &axset{}
		ax[i*2+1].stp = stp
		ax[i*2+1].isTkn = false
		ax[i*2+1].nAction = stp.nNtAct
	}

	var mxTknOfst, mnTknOfst = 0, 0
	var mxNtOfst, mnNtOfst = 0, 0

	// Compute the action table.  In order to try to keep the size of the
	// action table to a minimum, the heuristic of placing the largest action
	// sets first is used.
	sort.Sort(SortedAxset(ax))
	pActtab := acttab_alloc()

	for i := 0; i < lemp.nstate*2; i++ {
		stp := ax[i].stp
		if ax[i].isTkn {
			for ap := stp.ap; ap != nil; ap = ap.next {
				if ap.sp.index >= lemp.nterminal {
					continue
				}
				action := compute_action(lemp, ap)
				if action < 0 {
					continue
				}
				acttab_action(pActtab, ap.sp.index, action)
			}

			stp.iTknOfst = acttab_insert(pActtab)
			if stp.iTknOfst < mnTknOfst {
				mnTknOfst = stp.iTknOfst
			}
			if stp.iTknOfst > mxTknOfst {
				mxTknOfst = stp.iTknOfst
			}
		} else {
			for ap := stp.ap; ap != nil; ap = ap.next {

				if ap.sp.index < lemp.nterminal {
					continue
				}
				if ap.sp.index == lemp.nsymbol {
					continue
				}
				action := compute_action(lemp, ap)
				if action < 0 {
					continue
				}
				acttab_action(pActtab, ap.sp.index, action)
			}
			stp.iNtOfst = acttab_insert(pActtab)
			if stp.iNtOfst < mnNtOfst {
				mnNtOfst = stp.iNtOfst
			}
			if stp.iNtOfst > mxNtOfst {
				mxNtOfst = stp.iNtOfst
			}
		}
	}

	// free(ax)
	// Output the yy_action table

	fmt.Fprintf(out, "var YYACTIONTYPE []yy_action = {\n")
	lineno++
	n := acttab_size(pActtab)
	i, j := 0, 0
	for ; i < n; i++ {
		action := acttab_yyaction(pActtab, i)
		if action < 0 {
			action = lemp.nsymbol + lemp.nrule + 2
		}
		if j == 0 {
			fmt.Fprintf(out, " /* %5d */ ", i);
		}
		fmt.Fprintf(out, " %4d,", action)
		if j == 9 || i == n-1 {
			fmt.Fprintf(out, "\n")
			lineno++
			j = 0
		} else {
			j++
		}
	}
	fmt.Fprintf(out, "};\n")
	lineno++

	//  Output the yy_lookahead table
	fmt.Fprintf(out, "var YYCODETYPE []yy_lookahead = {\n")
	lineno++
	i, j = 0, 0
	for ; i < n; i++ {
		la := acttab_yylookahead(pActtab, i);
		if la < 0 {
			la = lemp.nsymbol
		}
		if j == 0 {
			fmt.Fprintf(out, " /* %5d */ ", i)
		}
		fmt.Fprintf(out, " %4d,", la)
		if j == 9 || i == n-1 {
			fmt.Fprintf(out, "\n")
			lineno++
			j = 0
		} else {
			j++
		}
	}
	fmt.Fprintf(out, "} \n")
	lineno++

	// Output the yy_shift_ofst[] table

	fmt.Fprintf(out, "const YY_SHIFT_USE_DFLT = %d \n", mnTknOfst-1)
	lineno++;
	fmt.Fprintf(out, "var  yy_shift_ofst []%s = {\n",
		minimum_size_type(mnTknOfst-1, mxTknOfst))
	lineno++
	n = lemp.nstate
	i, j = 0, 0
	for ; i < n; i++ {

		stp := lemp.sorted[i]
		ofst := stp.iTknOfst
		if ofst == NO_OFFSET {
			ofst = mnTknOfst - 1
		}
		if j == 0 {
			fmt.Fprintf(out, " /* %5d */ ", i)
		}
		fmt.Fprintf(out, " %4d,", ofst)
		if j == 9 || i == n-1 {
			fmt.Fprintf(out, "\n")
			lineno++
			j = 0
		} else {
			j++
		}
	}
	fmt.Fprintf(out, "} \n");
	lineno++

	// Output the yy_reduce_ofst[] table
	fmt.Fprintf(out, "const YY_REDUCE_USE_DFLT = %d \n", mnNtOfst-1)
	lineno++
	fmt.Fprintf(out, "var   yy_reduce_ofst []%s = {\n",
		minimum_size_type(mnNtOfst-1, mxNtOfst))
	lineno++
	n = lemp.nstate
	i, j = 0, 0
	for ; i < n; i++ {

		stp := lemp.sorted[i];
		ofst := stp.iNtOfst;
		if ofst == NO_OFFSET {
			ofst = mnNtOfst - 1
		}
		if j == 0 {
			fmt.Fprintf(out, " /* %5d */ ", i)
		}
		fmt.Fprintf(out, " %4d,", ofst);
		if j == 9 || i == n-1 {
			fmt.Fprintf(out, "\n")
			lineno++
			j = 0
		} else {
			j++
		}
	}
	fmt.Fprintf(out, "} \n");
	lineno++

	// Output the default action table

	fmt.Fprintf(out, "var yy_default []YYACTIONTYPE = {\n");
	lineno++;
	n = lemp.nstate
	i, j = 0, 0
	for ; i < n; i++ {
		stp := lemp.sorted[i];
		if j == 0 {
			fmt.Fprintf(out, " /* %5d */ ", i)
		}
		fmt.Fprintf(out, " %4d,", stp.iDflt)
		if j == 9 || i == n-1 {
			fmt.Fprintf(out, "\n")
			lineno++
			j = 0
		} else {
			j++;
		}
	}
	fmt.Fprintf(out, "} \n")
	lineno++
	tplt_xfer(lemp.name, in, out, &lineno)

	//Generate the table of fallback tokens.
	if lemp.has_fallback {
		for i = 0; i < lemp.nterminal; i++ {
			p := lemp.symbols[i];
			if p.fallback == nil {
				fmt.Fprintf(out, "    0,  /* %10s => nothing */\n", p.name)
			} else {
				fmt.Fprintf(out, "  %3d,  /* %10s => %s */\n", p.fallback.index,
					p.name, p.fallback.name)
			}
			lineno++
		}
	}
	tplt_xfer(lemp.name, in, out, &lineno)

	// Generate a table containing the symbolic name of every symbol

	for i = 0; i < lemp.nsymbol; i++ {
		line := fmt.Sprintf("\"%s\",", lemp.symbols[i].name)
		fmt.Fprintf(out, "  %-15s", line)
		if (i & 3) == 3 {
			fmt.Fprintf(out, "\n")
			lineno++;
		}
	}
	if (i & 3) != 0 {
		fmt.Fprintf(out, "\n")
		lineno++
	}
	tplt_xfer(lemp.name, in, out, &lineno)

	// Generate a table containing a text string that describes every
	// rule in the rule set of the grammer.  This information is used
	// when tracing REDUCE actions.
	i = 0
	rp := lemp.rule
	for ; rp != nil; {
		//	assert( rp.index==i );
		fmt.Fprintf(out, " /* %3d */ \"%s ::=", i, rp.lhs.name)
		for j = 0; j < rp.nrhs; j++ {
			fmt.Fprintf(out, " %s", rp.rhs[j].name)
		}
		fmt.Fprintf(out, "\",\n")
		lineno++
		rp = rp.next
		i++
	}
	tplt_xfer(lemp.name, in, out, &lineno)

	// Generate code which executes every time a symbol is popped from
	// the stack while processing errors or while destroying the parser.
	// (In other words, generate the %destructor actions)
	if len(lemp.tokendest) > 0 {
		for i = 0; i < lemp.nsymbol; i++ {
			sp := lemp.symbols[i]
			if sp == nil || sp.typ != TERMINAL {

				continue
			}
			fmt.Fprintf(out, "    case %d:\n", sp.index)
			lineno++
		}
		for i = 0; i < lemp.nsymbol && lemp.symbols[i].typ != TERMINAL; i++ {
		}
		if i < lemp.nsymbol {
			emit_destructor_code(out, lemp.symbols[i], lemp, &lineno)
			fmt.Fprintf(out, "      break;\n")
			lineno ++
		}
	}
	for i = 0; i < lemp.nsymbol; i++ {
		sp := lemp.symbols[i]
		if sp == nil || sp.typ == TERMINAL || len(sp.destructor) == 0 {
			continue
		}
		fmt.Fprintf(out, "    case %d:\n", sp.index)
		lineno ++
		emit_destructor_code(out, lemp.symbols[i], lemp, &lineno)
		fmt.Fprintf(out, "      break;\n")
		lineno++
	}
	if len(lemp.vardest) > 0 {
		var dflt_sp *symbol
		for i = 0; i < lemp.nsymbol; i++ {
			sp := lemp.symbols[i];
			if sp == nil || sp.typ == TERMINAL || sp.index <= 0 || len(sp.destructor) != 0 {
				continue
			}
			fmt.Fprintf(out, "    case %d:\n", sp.index)
			lineno++
			dflt_sp = sp
		}
		if dflt_sp != nil {
			emit_destructor_code(out, dflt_sp, lemp, &lineno)
			fmt.Fprintf(out, "      break;\n")
			lineno ++
		}
	}
	tplt_xfer(lemp.name, in, out, &lineno)

	//Generate code which executes whenever the parser stack overflows
	tplt_print(out, lemp, lemp.overflow, lemp.overflowln, &lineno)
	tplt_xfer(lemp.name, in, out, &lineno)

	// Generate the table of rule information
	// Note: This code depends on the fact that rules are number
	// sequentially beginning with 0.
	for rp = lemp.rule; rp != nil; rp = rp.next {
		fmt.Fprintf(out, "  { %d, %d },\n", rp.lhs.index, rp.nrhs)
		lineno++
	}
	tplt_xfer(lemp.name, in, out, &lineno)

	// Generate code which execution during each REDUCE action

	for rp = lemp.rule; rp != nil; rp = rp.next {
		fmt.Fprintf(out, "      case %d:\n", rp.index)
		lineno++
		emit_code(out, rp, lemp, &lineno)
		fmt.Fprintf(out, "        break;\n")
		lineno++
	}
	tplt_xfer(lemp.name, in, out, &lineno)

	// Generate code which executes if a parse fails
	tplt_print(out, lemp, lemp.failure, lemp.failureln, &lineno)
	tplt_xfer(lemp.name, in, out, &lineno)

	// Generate code which executes when a syntax error occurs
	tplt_print(out, lemp, lemp.error, lemp.errorln, &lineno)
	tplt_xfer(lemp.name, in, out, &lineno)

	// Generate code which executes when the parser accepts its input
	tplt_print(out, lemp, lemp.accept, lemp.acceptln, &lineno)
	tplt_xfer(lemp.name, in, out, &lineno)

	// Append any addition code the user desires
	tplt_print(out, lemp, lemp.extracode, lemp.extracodeln, &lineno)